#JVM
###类加载该过程
![Image text](image/类加载过程2.png)
####1.加载
    1.通过一个类的全限定类名获取定义此类的二进制字节流
    2.将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构
    3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
####加载.class文件的方式
    从本地系统中、网络获取（Web Applet）、gzip压缩包（jar、war）、JSP、加密文件

####2.验证
    目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全
    字节码是否已CAFE BABE开头、主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
####3.准备
    为类变量分配内存并且设置该类变量的默认初始值，即零值
    这里不包含用final修饰的static，因为final在编译的时候就会分配好了默认值，准备阶段会显式初始化
    （类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中）
####4.解析
    将常量池内的符号引用转换为直接引用的过程（其实是在初始化之后）
    解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。
    ps; java全部都是直接引用:
            变量直接指向堆地址
            好处是访问快、弊端是垃圾回收改了堆的位置后，需要在变量中重新修改指向堆的地址值
        间接引用用的是句柄池，变量到句柄池，在到堆地址
            好处是垃圾回收改了更新了堆地址后只需要修改句柄池中的地址、弊端是相对直接引用访问会慢一点
    
![Image text](image/句柄池.png)
####5.初始化
    执行类构造器方法<clinit>()的过程
    由编译器生成，如果类中没有static变量，则不会有clinit方法，（clinit方法中的指令按语句在源文件中出现的顺序执行）
    若该类具有父类，JVM会保证子类的<clinit>()执行前，父类的<clinit>()已经执行完毕
    虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁

###类加载器的分类
    分为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）
    1.启动类加载器(引导类加载器)
        C++实现，加载Java的核心库，没有父类加载器
    2.扩展类加载器
        继承于ClassLoader类，从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的 jre / lib / ext子目录（扩展目录）下加载类库。
    3.系统类加载器
        继承于ClassLoader类，程序中默认的类加载器
    4.用户自定义类加载器
        好处：隔离加载类、修改类加载的方式、扩展加载源、防止源码泄露
        实现：实现ClassLoader，重写findclass方法，不建议重写loadclass方法，因为loadclass方法中有双亲委派的原则，不希望被打破
        
###双亲委派机制
    概念：比如一个自己写的类,需要加载,被系统类加载器扫描到,他会抛给他的上级,给扩展类,然后启动类,发现他们都处理不了,
            然后在从启动类,到扩展类,到系统类,然后在加载,这就是双亲委派机制
    优势：避免类的重复加载
          保护程序安全，防止核心API被随意篡改
    就算我重写了loadclass方法，破坏了双亲委派机制，但是最终也不能加载自定义的String类，因为defineClass方法最终调用preDefineClass会保护JDK的核心类库
      
    
###破坏双亲委派机制
    通过线程上下文类加载器来感知下游类加载器的类
    双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如:代码热替换（Hot Swap）、模块热部署（Hot Deployment）等

###沙箱安全机制
    虚拟机会把所有代码加载到不同的系统域和应用域。系统域部分专门负责与关键资源进行交互，
    而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。
    虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。
    存在于不同域中的类文件就具有了当前域的全部权限，如下图所示，最新的安全模型（jdk1.6）
    ps：加载自定义类String的时候，向上委托，其他加载的是核心类库中的String，调用main的时候，发现核心类库中没有该方法，所以就报错，这就是沙箱保护机制
![Image text](image/沙箱安全.png)


#jvm问题
###如何判断两个class对象相同？
    同一个类加载器加载、全限定类名一致
###类的主动使用和被动使用
    主动使用：
        创建类的实例
        访问某个类或接口的静态变量，或者对该静态变量赋值
        调用类的静态方法
        反射（ 比如：Class.forName(“cn.sxt.Test”) )
        初始化一个类的子类
        Java虚拟机启动时被标明为启动类的类
        JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化
    
![Image text](image/运行时数据区.png)
![Image text](image/运行时数据区2.png)
###运行时数据区
####程序计数器
    线程私有 （由于多线程运行下，线程来回切换，每个线程记录自己的执行指令）
    没有OOM的发生
    PC寄存器用来存储指向下一条指令的地址，也就是即将要执行的指令代码。由执行引擎读取下一条指令，并执行该指令。
    程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成
        
###CPU时间片
    CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。
    在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。
    但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。
    
![Image text](image/栈帧.jpg)
###虚拟机栈
    线程私有
    没有GC,但会发生OOM或者StackoverflowError
        栈的空间是动态的或者是固定的
        固定情况下，申请不到容量后会报栈溢出（StackoverflowError）
        动态情况下，尝试扩展，如果在内存中申请不了后，就会报OOM
    其内部是一个个的栈帧，一个方法对应一个栈帧的入栈和出栈
        栈帧中保存方法的局部变量、基本数据类型变量 VS 引用类型变量（类、数组、接口）
####栈帧
    1.局部变量表（Local Variables）
        又称局部变量数组，size大小是在编译时期就确定的，存储方法参数、方法体内的局部变量、返回值类型
        slot变量槽，32位，可以放下int、float等4个字节及以下的，long或者double就需要占2个位置
![Image text](image/slot示例.png)
        
        Slot 的重复利用，一个局部变量出了其作用域，那么在其作用域之后声明新的局部变量就很有可能会复用过期局部变量的槽位。
![Image text](image/slot重复示例1.png)
![Image text](image/slot重复示例2.png)

    2.操作数栈（Operand Stack）（或表达式栈）
        在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）
        主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。长度在编译时期就已确定
        示例：iload0 iload1 --》iadd --》istore2 加载变量表0和1的2个数字，并且相加，然后存到索引为2的变量表中
![Image text](image/操作数栈add操作.png)
        
        栈顶缓存技术：由于操作数都在内存中，频繁的读写会降低效率，所以将栈顶元素全部缓存在物理CPU的寄存器中，
            以此降低对内存的读/写次数，提升执行引擎的执行效率。
 
    3.动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）
        指向运行时常量池中方法的引用
![Image text](image/动态链接.png)
####方法的调用：解析和分派
    静态链接与动态链接
        静态链接：被调用的目标方法在编译期确定，且运行期保持不变时
        动态链接：程序运行期将调用的方法的符号转换为直接引用，这种引用转换过程具备动态性
    方法绑定机制
        早期绑定：如果在编译期可知，且运行期保持不变时
        晚期绑定：在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法
            （例如多态，new子类对象后赋给父类变量或者接口，然后调用父类或者接口中的方法，就是晚期绑定，因为编译时确定不了）
    虚方法和非虚方法
        非虚方法：编译期就确定了具体的调用版本，这个版本在运行时是不可变的（静态方法、私有方法、final 方法、实例构造器、父类方法）
        虚方法：其他的都是虚方法
    动态类型语言和静态类型语言
        静态类型语言：对类型的检查是在编译期就是静态类型语言
        动态类型语言：对类型的检查是在运行期就是动态类型语言
    方法重写的本质   
        找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。
        如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束，如果不通过，则返回java.lang.IllegalAccessError 异常
        否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。
        如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。
    虚方法表
        JVM采用在类的方法区建立一个虚方法表（virtual method table）来实现
        每个类中都有一个虚方法表，表中存放着各个方法的实际入口
        类加载的链接阶段被创建并开始初始化
    4.方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）
        存放该方法的pc寄存器的值
        方法的结束，有两种方式。1.正常执行退出（返回该栈帧的pc寄存器的值） 2.出现异常，非正常退出（按照异常表Exception table，具体执行到哪个pc寄存器的值）
![Image text](image/异常表.png)

                反编译字节码文件，可得到 Exception table
                from ：字节码指令起始地址
                to ：字节码指令结束地址
                target ：出现异常跳转至地址为 11 的指令执行
                type ：捕获异常的类型
            区别：正常完成出口和异常完成出口的区别：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值
    5.一些附加信息
        栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息

###本地方法栈
    线程私有
    类似于虚拟机栈,java层面的native方法,用C++实现,通常与底层操作系统做交互
    
###堆
![Image text](image/堆.png)
![Image text](image/对象在堆中的晋升.png)
####新生区
    1.Eden区
        新对象放不下Eden区后,会触发MinorGC,将Eden和From区存活对象放入to区
       
    2.S1 S2区
        S1或S2对象满了后不会触发GC,必须是Eden区满了,才会GC,顺带清理from区,如清理后to区放不下,则一部分会进入老年代
        新生区的对象默认经历15次GC，将进入老年代
####养老区
    养老区内存不足时，再次触发Major GC，进行养老区的内存清理,若还是放不下对象,则OOM异常
####元空间


###GC垃圾回收器
    
    
    

###JVM参数设置
    -Xms600m 用于表示堆区的初始内存，等价于 -XX:InitialHeapSize
    -Xmx600m 则用于表示堆区的最大内存，等价于 -XX:MaxHeapSize
    -XX:+PrintGCDetails
    -XX:NewRatio=2 表示新生代占1，老年代占2，新生代占整个堆的1/3
    -XX:SurvivorRatio=8 Eden空间和另外两个survivor空间缺省所占的比例是8 : 1 : 1
    -XX:MaxTenuringThreshold=15 从新生代进入养老区的GC年龄
    
###常用调优工具
    JDK命令行
    Eclipse：Memory Analyzer Tool
    Jconsole
    Visual VM（实时监控 推荐~）
    Jprofiler（推荐~）
    Java Flight Recorder（实时监控）
    GCViewer
    GCEasy

    
        


    

    