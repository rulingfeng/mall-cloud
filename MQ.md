#MQ
    使用场景: 
        1.异步 
            如下单: 扣数据库库存\优惠卷\积分\ 可以通过异步队列去完成 提高接口响应时间
        2.削峰 
            能够抗住高并发, 以至于不会把服务器搞崩, 
        3.解耦
            和下单接口能够分开,实现解耦,以至于不用每次加东西都需要去修改下单的代码,并且不好排查问题
    
    使用消息队列带来的问题
        重复消费: 做消息幂等,强校验和弱校验,强校验如何加GMV和积分的,成功后可以通过一个流水表记录,弱校验可以放在redis的key中
        消息丢失: 
        消息的顺序消费:
            rocket举例:  MessageQueueSelector队列选择机制 三种实现
                1.我们可使用Hash取模法，让同一个订单发送到同一个队列中，再使用同步发送，当同个订单的创建消息发送成功，再发送支付消息。保证了发送有序。
                2.topic内的队列机制,可以保证存储满足FIFO,剩下的只需要消费者顺序消费即可。
                3.保证顺序发送，顺序消费由消费者业务保证!!!
                
        
    技术选型
        rabbitMq:万级吞吐,时效性微秒级(特性),可用性高,基本不丢失数据
        rocketMq:十万级吞吐,时效性毫秒级,可用性非常高,0丢失
        kafka :十万级吞吐,时效性毫秒,可用性非常高,0丢失
          
   ![](document/resource/MQ技术选型对比.png)
   
   ###rocketMq
        四大核心组成:
        
        NameServer: 
            是个功能齐全的服务器,比zookeeper更轻量,NameServer节点互相之间是独立的，没有任何信息交互,主要开销心跳检测和topic-broker
        Broker: 
            消息中转角色，负责存储消息，转发消息。定时将Topic信息注册到NameServer, nameServer的心跳连接和底层通信都是通过netty实现的,
        Producer:
            同步发送(收到接收方回应后,在会继续执行),异步发送(不许等待接收方回应,就会继续执行),单向发送(日志收集)
        Consumer:
            由用户部署，支持PUSH和PULL两种消费模式，支持集群消费和广播消息，提供实时的消息订阅机制。
            
            
        